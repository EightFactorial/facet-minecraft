//! TODO
#![no_std]

use core::fmt::Display;

use facet::Facet;
use facet_minecraft::{self as mc, Deserialize, deserialize::error::DeserializeError};

#[repr(transparent)]
struct TestCursor(&'static [u8]);

impl TestCursor {
    fn read<T: Deserialize<'static> + Facet<'static>>(
        &mut self,
    ) -> Result<T, DeserializeError<'static>> {
        let (value, remaining) = T::from_slice_remainder(self.0)?;
        self.0 = remaining;
        Ok(value)
    }
}

#[derive(Debug, Facet)]
struct Var<T>(#[facet(mc::variable)] pub T);

impl<T: Display> Display for Var<T> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        Display::fmt(&self.0, f)
    }
}
impl<T: PartialEq> PartialEq for Var<T> {
    fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
}

#[cfg(feature = "tracing")]
fn trace() -> tracing::subscriber::DefaultGuard {
    use tracing_subscriber::prelude::*;
    let subscriber =
        tracing_subscriber::registry().with(tracing_subscriber::fmt::layer().with_test_writer());
    tracing::subscriber::set_default(subscriber)
}

// -------------------------------------------------------------------------------------------------

macro_rules! test {
    ($ident:ident, bool => $($vals:expr),* => $data:expr) => {
        #[test]
        fn $ident() {
            #[cfg(feature = "tracing")]
            let _guard = trace();
            let mut cursor = TestCursor($data);

            $(
                let val = cursor.read::<bool>().unwrap();
                assert_eq!(val, $vals, "Expected {}, got {val}", $vals);
            )*

            assert!(cursor.0.is_empty(), "Expected to real all data, but {} bytes remain", cursor.0.len());
        }
    };
    ($ident:ident, Var<$ty:ty> => $($vals:expr),* => $data:expr) => {
        #[test]
        fn $ident() {
            #[cfg(feature = "tracing")]
            let _guard = trace();
            let mut cursor = TestCursor($data);

            $(
                let val = cursor.read::<Var<$ty>>().unwrap();
                assert_eq!(val, $vals, "Expected {}, got {val}", $vals);
            )*

            assert!(cursor.0.is_empty(), "Expected to real all data, but {} bytes remain", cursor.0.len());
        }
    };
    ($ident:ident, $ty:ty => $($vals:expr),* => $data:expr) => {
        #[test]
        fn $ident() {
            #[cfg(feature = "tracing")]
            let _guard = trace();
            let mut cursor = TestCursor($data);

            $(
                let val = cursor.read::<$ty>().unwrap();
                assert_eq!(val, $vals, "Expected {} ({:02x?}), got {val} ({:02x?})", $vals, <$ty>::to_be_bytes($vals), <$ty>::to_be_bytes(val));
            )*

            assert!(cursor.0.is_empty(), "Expected to real all data, but {} bytes remain", cursor.0.len());
        }
    };
}

test!(bool, bool => true, false, true, false => &[0x01, 0x00, 0x01, 0x00]);
test!(u8, u8 => 0, 1, 2, 254, 255 => &[0x00, 0x01, 0x02, 0xfe, 0xff]);
test!(i8, i8 => -128, -1, 0, 1, 127 => &[0x80, 0xff, 0x00, 0x01, 0x7f]);
test!(u16, u16 => 0, 1, 2, 65534, 65535 => &[0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xff, 0xfe, 0xff, 0xff]);
test!(i16, i16 => -32768, -1, 0, 1, 32767 => &[0x80, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x7f, 0xff]);
test!(u32, u32 => 0, 1, 2, 4294967294u32, 4294967295u32 => &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff]);
test!(i32, i32 => -2147483648i32, -1, 0, 1, 2147483647i32 => &[0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0xff, 0xff, 0xff]);
test!(u64, u64 => 0, 1, 2, 18446744073709551614u64, 18446744073709551615u64 => &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
test!(i64, i64 => -9223372036854775808i64, -1, 0, 1, 9223372036854775807i64 => &[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
test!(u128, u128 => 0, 1, 2, 340282366920938463463374607431768211454u128, 340282366920938463463374607431768211455u128 => &[
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]);
test!(i128, i128 => -170141183460469231731687303715884105728i128, -1, 0, 1, 170141183460469231731687303715884105727i128 => &[
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
]);

test!(var_u16, Var<u16> => Var(0), Var(1), Var(2), Var(65534), Var(65535) => &[0x00, 0x01, 0x02, 0xfe, 0xff, 0x03, 0xff, 0xff, 0x03]);
test!(var_i16, Var<i16> => Var(-32768), Var(-1), Var(0), Var(1), Var(32767) => &[0x80, 0x80, 0x7e, 0xff, 0xff, 0x03, 0x00, 0x01, 0xff, 0xff, 0x01]);
test!(var_u32, Var<u32> => Var(0), Var(1), Var(2), Var(4294967294u32), Var(4294967295u32) => &[0x00, 0x01, 0x02, 0xfe, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x0f]);
test!(var_i32, Var<i32> => Var(-2147483648i32), Var(-1), Var(0), Var(1), Var(2147483647i32) => &[0x80, 0x80, 0x80, 0x80, 0x78, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x07]);
test!(var_u64, Var<u64> => Var(0), Var(1), Var(2), Var(18446744073709551614u64), Var(18446744073709551615u64) => &[0x00, 0x01, 0x02, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01]);
test!(var_i64, Var<i64> => Var(-9223372036854775808i64), Var(-1), Var(0), Var(1), Var(9223372036854775807i64) => &[0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]);
test!(var_u128, Var<u128> => Var(0), Var(1), Var(2), Var(340282366920938463463374607431768211454u128), Var(340282366920938463463374607431768211455u128) => &[
    0x00, 0x01, 0x02, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03
]);
test!(var_i128, Var<i128> => Var(-170141183460469231731687303715884105728i128), Var(-1), Var(0), Var(1), Var(170141183460469231731687303715884105727i128) => &[
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01
]);
